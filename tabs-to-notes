#!/bin/bash

# Copy as Markdown extension for Chrome
# 
# https://chromewebstore.google.com/detail/copy-as-markdown/fkeaekngjflipcockcnpobkpbbfbhmdn

SCRIPTS_PATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

OUTPUT_TABS_PATH_PREFIX="$HOME/tx/notes/fastnote/tabs/tabs-"
OUTPUT_TABS_PATH_SUFFIX=".txt"
DEFAULT_GROUP_NAME="sort"

INPUT_FILE_PATH="$1"

if [ -n "$INPUT_FILE_PATH" ]; then
  ALL_LINES_RAW=$(cat "$INPUT_FILE_PATH")
else
  ALL_LINES_RAW=$(xclip -selection clipboard -o)
fi

function all_links_count {
  echo -e "$1" \
    | rg '://' \
    | wc -l
}

function ask_continue { action_name="$@"
  if [[ -z "${action_name}" ]]; then
    action_name="continue"
  fi

  # -s	        do not echo input coming from a terminal
  # -p          prompt	output the string PROMPT without a trailing newline before
  #       attempting to read
  # -r  	  	  do not allow backslashes to escape any characters
  # -n nchars	  return after reading NCHARS characters rather than waiting
  #    		for a newline,
  read -n 1 -r -p "(Press \"y\" to ${action_name}): " input

  # new line but with stderr, escaping capture output
  echo >&2

  if [ "$input" != "Y" ] && [ "$input" != "y" ] && [ "$input" != "ะด" ] && [ "$input" != "ะ" ]; then
    exit
  fi
  echo 1
}

# Example:
#
# if [[ "$(ask_continue 'delete existing backup branches for most recent commit')" != "1" ]]; then
#   exit
# fi
#
#
#ASK_RESULT=$(ask_continue "roll back \"$BRANCH\" branch to \"$BRANCH\"/origin and LOSE CHANGES")
#
#if [[ "$ASK_RESULT" != "1" ]]; then
#  exit
#fi

echo "Links count raw: "$(all_links_count "$ALL_LINES_RAW")

ALL_LINES_FILTERED=$(
  echo -e "$ALL_LINES_RAW" \
    | rg --fixed-strings -v "chrome-extension://"
    # rg -v 'chrome'
  # rg -v 'chrome-extension'
  # rg --fixed-strings -v 'chrome-extension'
  # rg --fixed-strings -v 'chrome-extension://'
)

echo "Links count filtered: "$(all_links_count "$ALL_LINES_FILTERED")

# echo "$ALL_LINES_RAW" 

# add group header
ALL_LINES_FIX_UNSORTED_1=$( \
  echo -e "$ALL_LINES_FILTERED" \
  | rg '^((-.*://.*\n)+)' \
    --replace "- ${DEFAULT_GROUP_NAME}\n\$1" \
    --multiline \
    --passthru \
  | sed -e 's|\\n|\n|g'
)

# echo "$ALL_LINES_FIX_UNSORTED_1"

# add padding to tabs withour group
ALL_LINES_FIX_UNSORTED_2=$( \
  echo -e "$ALL_LINES_FIX_UNSORTED_1" \
  | rg '^(-.*://.*)' \
    --replace "  \$1" \
    --multiline \
    --passthru
)

ALL_LINES=$(echo -e "$ALL_LINES_FIX_UNSORTED_2")

echo -e "$ALL_LINES"


GROUPS_INFO=$( \
  echo -e "$ALL_LINES" \
  | rg -n -v '://' \
  | rg --replace "" '([- \[\]]+)'
)

ALL_LINES_LEN=$(echo -e "$ALL_LINES" | wc -l)

echo "ALL_LINES_LEN: $ALL_LINES_LEN"

echo
echo "GROUPS_INFO:"
echo -e "$GROUPS_INFO"
echo

GROUPS_INFO_ARRAY=()

# Set the Internal Field Separator to newline
IFS=$'\n'
  while read LINE; do
      # echo "LINE: $LINE"
      GROUPS_INFO_ARRAY+=("$LINE")
  done <<< "$GROUPS_INFO"
unset IFS

GROUPS_INFO_LEN=${#GROUPS_INFO_ARRAY[@]}

for(( i=0; i<$GROUPS_INFO_LEN; i++ )); do
	GROUP_INFO="${GROUPS_INFO_ARRAY[i]}"
	NEXT_GROUP_INFO="${GROUPS_INFO_ARRAY[i+1]}"

  # echo -e "cur: $GROUP_INFO"
  # echo -e "next: $NEXT_GROUP_INFO"

  GROUP_INFO_PARTS=(${GROUP_INFO//:/ })
  GROUP_NAME_LINE_NUM=${GROUP_INFO_PARTS[0]}
  GROUP_NAME=${GROUP_INFO_PARTS[1]}
  echo "$GROUP_NAME"
  # echo "$GROUP_NAME_LINE_NUM"

  NEXT_GROUP_INFO_PARTS=(${NEXT_GROUP_INFO//:/ })
  NEXT_GROUP_NAME_LINE_NUM=${NEXT_GROUP_INFO_PARTS[0]}
  # echo "$NEXT_GROUP_NAME_LINE_NUM"
  
  GROUP_LINES_BEGIN=$(expr $GROUP_NAME_LINE_NUM + 1)
  GROUP_LINES_END=$ALL_LINES_LEN

  if [ -n "$NEXT_GROUP_INFO_PARTS" ]; then
    GROUP_LINES_END=$(expr $NEXT_GROUP_NAME_LINE_NUM - 1)
  fi

  echo "$GROUP_LINES_BEGIN - $GROUP_LINES_END"

  GROUP_LINES=$(echo "$ALL_LINES" | sed -n "${GROUP_LINES_BEGIN},${GROUP_LINES_END}p")

  echo -e "$GROUP_LINES"

  OUTPUT_TABS_PATH="${OUTPUT_TABS_PATH_PREFIX}${GROUP_NAME}${OUTPUT_TABS_PATH_SUFFIX}"
  echo "$OUTPUT_TABS_PATH"
  echo

  # cat "$OUTPUT_TABS_PATH"
  
  if [ ! -f "$OUTPUT_TABS_PATH" ]; then
    if [[ "$(ask_continue "create $OUTPUT_TABS_PATH (it doesn't exist yet)")" != "1" ]]; then
      continue
    fi

    echo -e "# Tabs: $GROUP_NAME\n" > "$OUTPUT_TABS_PATH"
  fi # if not path

done


